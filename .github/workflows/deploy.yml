name: Deploy 2048 to ECS Fargate (Committed Terraform)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  PROJECT_NAME: game-2048
  TF_STATE_KEY: terraform.tfstate
  DOCKERFILE: app/Dockerfile
  DOCKER_CONTEXT: app

concurrency:
  group: deploy-2048
  cancel-in-progress: false

jobs:
  bootstrap_state:
    name: Bootstrap backend (S3 + DynamoDB) if needed
    runs-on: ubuntu-latest
    permissions: { contents: read }
    env:
      BOOTSTRAP_BUCKET_PREFIX: tfstate
      LOCK_TABLE_NAME: tf-locks
    steps:
      - name: Configure AWS (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Compute deterministic bucket name from repo + account
        id: ids
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REPO_SLUG="${{ github.repository }}" # owner/repo
          BUCKET_NAME="${REPO_SLUG//\//-}-${{ env.BOOTSTRAP_BUCKET_PREFIX }}-${ACCOUNT_ID}"
          echo "account_id=$ACCOUNT_ID"   >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

      - name: Create S3 bucket (if missing)
        run: |
          BUCKET="${{ steps.ids.outputs.bucket_name }}"
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            aws s3api create-bucket --bucket "$BUCKET" --region $AWS_REGION               --create-bucket-configuration LocationConstraint=$AWS_REGION
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{
              "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration               '{"BlockPublicAcls":true,"IgnorePublicAcls":true,"BlockPublicPolicy":true,"RestrictPublicBuckets":true}'
          fi

      - name: Create DynamoDB lock table (if missing)
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.LOCK_TABLE_NAME }} >/dev/null 2>&1; then
            aws dynamodb create-table --table-name ${{ env.LOCK_TABLE_NAME }}               --attribute-definitions AttributeName=LockID,AttributeType=S               --key-schema AttributeName=LockID,KeyType=HASH               --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name ${{ env.LOCK_TABLE_NAME }}
          fi

      - name: Expose backend values
        id: backend
        run: |
          echo "bucket=${{ steps.ids.outputs.bucket_name }}" >> $GITHUB_OUTPUT
          echo "table=${{ env.LOCK_TABLE_NAME }}"            >> $GITHUB_OUTPUT

    outputs:
      tf_bucket: ${{ steps.backend.outputs.bucket }}
      tf_table:  ${{ steps.backend.outputs.table }}

  seed_ecr:
    name: Ensure ECR exists (Terraform target apply)
    runs-on: ubuntu-latest
    needs: bootstrap_state
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ needs.bootstrap_state.outputs.tf_bucket }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ needs.bootstrap_state.outputs.tf_table }}"
          encrypt        = true
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Create only ECR (so we can push image)
        working-directory: terraform
        run: terraform apply -auto-approve -target=aws_ecr_repository.app

      - name: Get ECR URL
        id: out
        working-directory: terraform
        run: echo "ecr_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

    outputs:
      ecr_url: ${{ steps.out.outputs.ecr_url }}

  build_and_push:
    name: Build & push Docker image
    runs-on: ubuntu-latest
    needs: seed_ecr
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION             | docker login --username AWS --password-stdin ${{ needs.seed_ecr.outputs.ecr_url }}

      - name: Build
        run: docker build -f "$DOCKERFILE" -t app:${{ github.sha }} "$DOCKER_CONTEXT"

      - name: Tag & push
        run: |
          docker tag app:${{ github.sha }} ${{ needs.seed_ecr.outputs.ecr_url }}:${{ github.sha }}
          docker push ${{ needs.seed_ecr.outputs.ecr_url }}:${{ github.sha }}

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [bootstrap_state, build_and_push]
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Terraform fmt & validate
        working-directory: terraform
        run: |
          terraform fmt -check -recursive
          terraform validate

      - name: Terraform Plan (with image tag)
        working-directory: terraform
        run: terraform plan -var="region=${{ env.AWS_REGION }}" -var="image_tag=${{ github.sha }}"

  apply:
    name: Terraform Apply (deploy)
    runs-on: ubuntu-latest
    needs: plan
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Terraform Apply (with image tag)
        id: tfapply
        working-directory: terraform
        run: terraform apply -auto-approve -var="region=${{ env.AWS_REGION }}" -var="image_tag=${{ github.sha }}"

      - name: Output ALB
        id: out
        working-directory: terraform
        run: echo "alb=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

    outputs:
      alb: ${{ steps.out.outputs.alb }}

  smoke_test:
    name: Smoke test
    runs-on: ubuntu-latest
    needs: apply
    steps:
      - name: Wait a bit for stabilization
        run: sleep 30

      - name: Curl homepage until 200
        run: |
          URL="http://${{ needs.apply.outputs.alb }}"
          echo "Hitting $URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$code" = "200" ]; then
              echo "OK (200) at $URL"
              exit 0
            fi
            echo "Attempt $i -> $code"
            sleep 5
          done
          echo "Service did not return 200 in time"
          exit 1
