name: Deploy 2048 to ECS Fargate (Committed Terraform + Auto Dockerfile Detect)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  PROJECT_NAME: game-2048
  TF_STATE_KEY: terraform.tfstate
  DOCKERFILE: app/Dockerfile
  BUILD_CONTEXT: app
  ECR_REPO_NAME: akuphe-2048-game-repo

concurrency:
  group: deploy-2048
  cancel-in-progress: false

jobs:
  bootstrap_state:
    name: Bootstrap backend (S3 + DynamoDB) if needed
    runs-on: ubuntu-latest
    permissions: { contents: read }
    env:
      BOOTSTRAP_BUCKET_PREFIX: tfstate
      LOCK_TABLE_NAME: tf-locks
    steps:
      - name: Configure AWS (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Compute deterministic bucket name (<=63 chars, lowercase, ends with alnum)
        id: ids
        run: |
          REPO_SLUG="${{ github.repository }}"              # owner/repo
          SLUG_LOWER=$(echo "$REPO_SLUG" | tr '[:upper:]' '[:lower:]')
          BASE=$(echo "$SLUG_LOWER" | sed -E 's/[^a-z0-9-]/-/g; s/-+/-/g; s/^-+//; s/-+$//')
          BASE=${BASE:0:32}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SUFFIX=$(printf '%s' "$SLUG_LOWER" | sha1sum | cut -c1-8)
          BUCKET="${BASE}-${ACCOUNT_ID}-${SUFFIX}-tf"
          BUCKET=$(echo "$BUCKET" | sed -E 's/^-+//; s/-+$//')
          echo "bucket_name=$BUCKET" >> $GITHUB_OUTPUT
          echo "Bucket: $BUCKET (len=$(echo -n $BUCKET | wc -c))"

      - name: Create S3 bucket (if missing)
        env:
          BUCKET: ${{ steps.ids.outputs.bucket_name }}
        run: |
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" --region "$AWS_REGION"                 --create-bucket-configuration LocationConstraint="$AWS_REGION"
            fi
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{
              "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration               '{"BlockPublicAcls":true,"IgnorePublicAcls":true,"BlockPublicPolicy":true,"RestrictPublicBuckets":true}'
          fi

      - name: Create DynamoDB lock table (if missing)
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.LOCK_TABLE_NAME }} >/dev/null 2>&1; then
            aws dynamodb create-table --table-name ${{ env.LOCK_TABLE_NAME }}               --attribute-definitions AttributeName=LockID,AttributeType=S               --key-schema AttributeName=LockID,KeyType=HASH               --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name ${{ env.LOCK_TABLE_NAME }}
          fi

      - name: Expose backend values
        id: backend
        run: |
          echo "bucket=${{ steps.ids.outputs.bucket_name }}" >> $GITHUB_OUTPUT
          echo "table=${{ env.LOCK_TABLE_NAME }}"            >> $GITHUB_OUTPUT

    outputs:
      tf_bucket: ${{ steps.backend.outputs.bucket }}
      tf_table:  ${{ steps.backend.outputs.table }}

  seed_ecr:
    name: Ensure ECR exists (Terraform target apply)
    runs-on: ubuntu-latest
    needs: bootstrap_state
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ needs.bootstrap_state.outputs.tf_bucket }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ needs.bootstrap_state.outputs.tf_table }}"
          encrypt        = true
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Create only ECR (so we can push image)
        working-directory: terraform
        run: |
          terraform apply -auto-approve             -target=aws_ecr_repository.app             -var="region=${{ env.AWS_REGION }}"             -var="ecr_repo_name=${{ env.ECR_REPO_NAME }}"

      - name: Get ECR repo URL (output)
        id: out
        working-directory: terraform
        run: |
          ECR_URL="$(terraform output -raw ecr_repository_url || true)"
          echo "ecr_url=$ECR_URL" >> $GITHUB_OUTPUT

    outputs:
      ecr_url: ${{ steps.out.outputs.ecr_url }}

  build_and_push:
    name: Build & push Docker image (latest + SHA)
    runs-on: ubuntu-latest
    needs: seed_ecr
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Ensure Docker uses default context (avoid DOCKER_CONTEXT conflicts)
        run: |
          docker context use default || true
          unset DOCKER_CONTEXT || true

      - name: Derive ECR registry + repo (robust)
        id: ecr
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          REPO_URL="${{ needs.seed_ecr.outputs.ecr_url }}"
          if [ -z "$REPO_URL" ]; then
            REPO_URL="${REGISTRY}/${ECR_REPO_NAME}"
          fi
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "Resolved registry: $REGISTRY"
          echo "Resolved repo_url: $REPO_URL"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION"             | docker login --username AWS --password-stdin "${{ steps.ecr.outputs.registry }}"

      - name: Locate Dockerfile & context (auto-fallback if configured paths missing)
        id: locate
        run: |
          if [ -f "$DOCKERFILE" ] && [ -d "$BUILD_CONTEXT" ]; then
            DF="$DOCKERFILE"; CTX="$BUILD_CONTEXT"
          else
            echo "Configured paths not found. Auto-detecting..."
            DF=$(git ls-files | grep -E '(^|/)Dockerfile$' | head -n1 || true)
            if [ -z "$DF" ]; then
              echo "No Dockerfile found in repository." >&2
              exit 1
            fi
            CTX=$(dirname "$DF")
            [ -z "$CTX" ] && CTX="."
          fi
          echo "dockerfile=$DF" >> $GITHUB_OUTPUT
          echo "context=$CTX" >> $GITHUB_OUTPUT
          echo "Using Dockerfile: $DF"
          echo "Using build context: $CTX"

      - name: Build
        run: docker build -f "${{ steps.locate.outputs.dockerfile }}" -t app:${{ github.sha }} "${{ steps.locate.outputs.context }}"

      - name: Tag & push (latest + SHA)
        run: |
          REPO="${{ steps.ecr.outputs.repo_url }}"
          docker tag app:${{ github.sha }} "$REPO":${{ github.sha }}
          docker tag app:${{ github.sha }} "$REPO":latest
          docker push "$REPO":${{ github.sha }}
          docker push "$REPO":latest

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [bootstrap_state, build_and_push]
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl (this job)
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ needs.bootstrap_state.outputs.tf_bucket }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ needs.bootstrap_state.outputs.tf_table }}"
          encrypt        = true
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Terraform fmt & validate
        working-directory: terraform
        run: |
          terraform fmt -check -recursive
          terraform validate

      - name: Terraform Plan (with image tag)
        working-directory: terraform
        run: |
          terraform plan             -var="region=${{ env.AWS_REGION }}"             -var="image_tag=${{ github.sha }}"             -var="ecr_repo_name=${{ env.ECR_REPO_NAME }}"

  apply:
    name: Terraform Apply (deploy)
    runs-on: ubuntu-latest
    needs: plan
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl (this job)
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ needs.bootstrap_state.outputs.tf_bucket }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ needs.bootstrap_state.outputs.tf_table }}"
          encrypt        = true
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=backend.hcl

      - name: Terraform Apply (with image tag)
        id: tfapply
        working-directory: terraform
        run: |
          terraform apply -auto-approve             -var="region=${{ env.AWS_REGION }}"             -var="image_tag=${{ github.sha }}"             -var="ecr_repo_name=${{ env.ECR_REPO_NAME }}"

      - name: Output ALB
        id: out
        working-directory: terraform
        run: echo "alb=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

    outputs:
      alb: ${{ steps.out.outputs.alb }}

  smoke_test:
    name: Smoke test
    runs-on: ubuntu-latest
    needs: apply
    steps:
      - name: Wait a bit for stabilization
        run: sleep 30

      - name: Curl homepage until 200
        run: |
          URL="http://${{ needs.apply.outputs.alb }}"
          echo "Hitting $URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$code" = "200" ]; then
              echo "OK (200) at $URL"
              exit 0
            fi
            echo "Attempt $i -> $code"
            sleep 5
          done
          echo "Service did not return 200 in time"
          exit 1
